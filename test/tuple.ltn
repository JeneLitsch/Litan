namespace sphinx::test {
	function tuple_single_element() {
		var tuple = (1,);
		assert_equal_strict(tuple[0], 1);
	}



	function tuple_read_elements() {
		var tuple = (1, 2.0, "abc");
		assert_equal_strict(tuple[0], 1);
		assert_equal_strict(tuple[1], 2.0);
		assert_equal_strict(tuple[2], "abc");
	}



	function tuple_expr_type() {
		var got = reflect(expr (1, true, true)).type.name;
		var expected = "tuple<int, bool, bool>";
		assert_equal_strict(got, expected);
	}



	function tuple_var_type() {
		var tuple = (1, 2.0, "xyz");
		var got = reflect(expr tuple).type.name;
		var expected = "tuple<int, float, string>";
		assert_equal_strict(got, expected);
	}



	function tuple_elem_type_direct() {
		var tuple = (1, 2.0, "xyz");
		assert_equal_strict(reflect(expr tuple[0]).type.name, "int");
		assert_equal_strict(reflect(expr tuple[1]).type.name, "float");
		assert_equal_strict(reflect(expr tuple[2]).type.name, "string");
	}



	function tuple_elem_type_indirect() {
		var tuple = (1, 2.0, "xyz");
		assert_equal_strict(reflect(expr tuple[0 + 0]).type.name, "any");
		assert_equal_strict(reflect(expr tuple[1 + 0]).type.name, "any");
		assert_equal_strict(reflect(expr tuple[2 + 0]).type.name, "any");
	}



	function tuple_assign() {
		var tuple = (true, 3, 9.0);
		tuple = (false, 42, 3.14);
		assert_equal_strict(tuple, (false, 42, 3.14));
	}



	function tuple_compare() {
		assert_false((false,)   == (true,));
		assert_false((true, 42) == (false, 43));
		assert_true((true, 42, 3.14) == (true, 42, 3.14));
		assert_true((true,) == (true,));
		assert_false((true,true) == (true,));
	}



	function tuple_ordering_length() {
		assert_equal((1,1) <=> (1,1), 0);
		assert_equal((1) <=> (1,1), -1);
		assert_equal((1,1,1) <=> (1,1), 1);
		assert_equal((1, (1,)) <=> (1, (1, 1)), -1);
	}



	function tuple_ordering_elements() {
		assert_equal((1, 2) <=> (1, 1), 1);
		assert_equal((1, 2) <=> (1, 3), -1);
		assert_equal((1, 2) <=> (1, 2), 0);
		assert_equal((1, (1, 2)) <=> (1, (1, 1)), 1);
	}



	function tuple_assign_element() {
		var tuple = (1,2,3);
		tuple[0] = 10;
		tuple[1] = 20;
		tuple[2] = 30;
		assert_equal_strict(tuple, (10, 20, 30));
	}



	function tuple_add() {
		assert_equal_strict((1,) + (2,), (1,2));
		assert_equal_strict((1, "a") + (2,), (1, "a", 2));
	}


	
	function tuple_add_type() {
		var t1 = (1, 2);
		var t2 = (true, "abc");
		var t3 = t1 + t2;
		var t4 = t2 + t1;
		
		assert_equal_strict(
			reflect(expr t3).type.name,
			"tuple<int, int, bool, string>"
		);

		assert_equal_strict(
			reflect(expr t4).type.name,
			"tuple<bool, string, int, int>"
		);
	}



	function tuple_type() {
		assert_equal_strict(
			reflect(type tuple<int, string>).name,
			"tuple<int, string>"
		);

		assert_equal_strict(
			reflect(type tuple<int, tuple<string, int>>).name,
			"tuple<int, tuple<string, int>>"
		);
	}



	namespace tuple_local {
		function f_return()
			-> tuple<int, float>
			=> (1, 1.0)

		function f_parameter(tuple : tuple<int, float, string>)
			-> null
			=> null

		function f_both(tuple : tuple<int, float, string>)
			-> tuple<int, float>
			=> (tuple[0], tuple[1])
	}



	function tuple_functions() {
		var tuple1 = tuple_local::f_return();
		tuple_local::f_parameter((0, 3.14, "xyz"));
		var tuple2 = tuple_local::f_both((0, 3.14, "xyz"));
	}
}